/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "sxfs.h"
#include "string.h"
#include "stdlib.h"
#include <unistd.h>
#include <string>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <thread>
#include <iostream>


using namespace std;

class Client;

class Client {

public:
	CLIENT *clnt;
	std::thread udp_thread;
	int sock = -1;
	char *self_ip;
	int self_port;
    client_file_list self_file_list;

    void file_find(char *filename);
    void get_load(IP ip, int port);
    void download(IP ip, int port);
    void update_list(IP ip, int port, client_file_list f_list);
	client_file_list populate_file_list();

	Client(char *ip, char *host, int port) {
		self_ip = ip;
		self_port = port;
		clnt = clnt_create(host, SIMPLE_XFS, SIMPLE_VERSION, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror(host);
			exit(1);
		}

		self_file_list = populate_file_list();
        update_list(self_ip, self_port, self_file_list);
        std::cout << ".....Completed client creation.....\n";
        //outputClientList();

//		struct sockaddr_in client_addr;
//		if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
//			perror("socket()");
//			exit(1);
//		}
//		int optval = 1;
//		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &optval, sizeof(int));
//		memset(&client_addr, 0, sizeof(client_addr));
//		client_addr.sin_family = AF_INET;
//		client_addr.sin_addr.s_addr = htonl(INADDR_ANY);
//		client_addr.sin_port = htons(self_port);
//
//		if (bind(sock, (struct sockaddr *) &client_addr, sizeof(client_addr)) == -1) {
//			close(sock);
//			perror("binding socket");
//		}
	}

	~Client() {
		if (udp_thread.joinable()) {
			udp_thread.join();
		}
		if (clnt)
			clnt_destroy(clnt);

	}

};

client_file_list Client:: populate_file_list() {
//TODO

	client_file_list temp_list;
	temp_list.client_file_list_len = 3;
	temp_list.client_file_list_val = new FILENAME[3];
	for(int j = 0; j<temp_list.client_file_list_len; j++){
		FILENAME tmp = (FILENAME )"file1.txt";
		temp_list.client_file_list_val[j] = tmp;
	}
	return temp_list;
}

void Client::file_find(char *filename) {
	auto result_1 = file_find_1(filename, clnt);
	if (result_1 == (node_list *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	cout << "Node_list for " << filename << " is:\n";
	for (int i = 0; i < result_1->node_list_len; i++) {
		cout << (result_1->node_list_val + i)->ip << ":" << (result_1->node_list_val+i)->port << " ";
	}
	cout << "\n";

}

void Client::get_load(IP ip, int port) { //TODO: make it UDP


    //if peer crashed
    //TODO: remove client from file_specific_client_list and then call update_list
}

void Client::download(IP ip, int port) { //TODO: make it UDP
    //TODO: implement latency in sending
    //recv_from();
    //calculate checksum of downloaded file
    //compare with original file and output success if checksum matches
    //if success, add itself to the file_specific_client_list and call update_list




    //if peer crashed
    //TODO: remove client from file_specific_client_list and then call update_list
}

//TODO: update list to be called if download returned success
void Client::update_list(IP ip, int port, client_file_list f_list) {
    auto result_4 = update_list_1(ip, port, f_list, clnt);
    if (result_4 == (int *) NULL) {
        clnt_perror(clnt, "call failed");
    }
}


//TODO: UPDATE_LIST to be called whever joining too.... if already in list, overwrite else push back

//TODO: scenario of a client leaving and then joining back cz we need checksum too

int
main (int argc, char *argv[])
{
    if (argc < 4) {
        std::cout << "Usage: ./clientside client_ip server_ip client_port\n";
        exit(1);
    }
    char *client_ip = (char *) argv[1];
    char *serv_ip = (char *) argv[2];
    int self_port = stoi(argv[3]);

    Client conn(client_ip, serv_ip, self_port);

	char search_filename[MAXFILENAME];
	strcpy(search_filename,"file1.txt");
	conn.file_find(search_filename);
    exit (0);
}
