/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <iostream>
#include "peer_info.h"
#include "sxfs.h"
#include "string.h"
#include "stdlib.h"
#include <unistd.h>
#include <string>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <thread>

using namespace std;

//client_list buildClientList() {
//	client_list res;
//	res.client_list_val = new node[clientList.size()];
//	res.client_list_len = clientList.size();
//	int pos = 0;
//	for (int i = 0; i < clientList.size(); i++) {
//		node *p = res.client_list_val + pos;
//		p->ip = new char[clientList[i].first.length() + 1];
//		strcpy(p->ip, clientList[i].first.c_str());
//		p->port = clientList[i].second;
//		pos++;
//	}
//	return res;
//}
//
//void outputClientList() {
//	//output server list;
//	cout << "outputing server list:" << endl;
//    client_list clients = this->buildClientList();
//	for (int i = 0; i < clients.client_list_len; i++) {
//		cout << (clients.client_list_val + i)->ip << " " << (clients.client_list_val + i)->port << endl;
//	}
//	cout << endl;
//}

class Client;

class Client {

public:
	CLIENT *clnt;
	std::thread udp_thread;
	int sock = -1;
	char *self_ip;
	int self_port;
    client_file_list self_file_list;

    void file_find(char *filename);
    void get_load(IP ip, int port);
    void download(IP ip, int port);
    void update_list(IP ip, int port, client_file_list f_list);

	Client(char *ip, char *host, int port) {
		self_ip = ip;
		self_port = port;
		clnt = clnt_create(host, SIMPLE_XFS, SIMPLE_VERSION, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror(host);
			exit(1);
		}

        update_list(self_ip, self_port, self_file_list);
        std::cout << ".....Completed client creation.....\n";
        //outputClientList();

		struct sockaddr_in client_addr;
		if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
			perror("socket()");
			exit(1);
		}
		int optval = 1;
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &optval, sizeof(int));
		memset(&client_addr, 0, sizeof(client_addr));
		client_addr.sin_family = AF_INET;
		client_addr.sin_addr.s_addr = htonl(INADDR_ANY);
		client_addr.sin_port = htons(self_port);

		if (bind(sock, (struct sockaddr *) &client_addr, sizeof(client_addr)) == -1) {
			close(sock);
			perror("binding socket");
		}


	}

	~Client() {
		if (udp_thread.joinable()) {
			udp_thread.join();
		}
		if (clnt)
			clnt_destroy(clnt);

	}

};

void Client::file_find(char *filename) {
	auto result_1 = file_find_1(filename, clnt);
	if (result_1 == (node_list *) NULL) {
		clnt_perror(clnt, "call failed");
	}
}

void Client::get_load(IP ip, int port) { //TODO: make it UDP


    //if peer crashed
    //TODO: remove client from file_specific_client_list and then call update_list
}

void Client::download(IP ip, int port) { //TODO: make it UDP
    //TODO: implement latency in sending
    //recv_from();
    //calculate checksum of downloaded file
    //compare with original file and output success if checksum matches
    //if success, add itself to the file_specific_client_list and call update_list




    //if peer crashed
    //TODO: remove client from file_specific_client_list and then call update_list
}

//TODO: update list to be called if download returned success
void Client::update_list(IP ip, int port, client_file_list f_list) {
    auto result_4 = update_list_1(ip, port, f_list, clnt);
    if (result_4 == (int *) NULL) {
        clnt_perror(clnt, "call failed");
    }
}


//TODO: UPDATE_LIST to be called whever joining too.... if already in list, overwrite else push back

//TODO: scenario of a client leaving and then joining back cz we need checksum too

int
main (int argc, char *argv[])
{
    if (argc < 4) {
        std::cout << "Usage: ./clientside client_ip server_ip client_port\n";
        exit(1);
    }
    char *client_ip = (char *) argv[1];
    char *serv_ip = (char *) argv[2];
    int self_port = stoi(argv[3]);

    Client conn(client_ip, serv_ip, self_port);
    char func[1];
    int func_number;

    exit (0);
}
