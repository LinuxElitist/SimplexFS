/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "sxfs.h"
#include <sstream>
#include "tcp_communication.h"
#include "tcp_client.h"
#include "tcp_server.h"
#include <thread>
#include <unistd.h>
#include <map>
#include <iostream>

using namespace std;

static map<pair<string,int>,pair<string,int>> clientList;
static map<pair<string,int>,pair<string,int>>::iterator it = clientList.begin();


void outputClientList() {
	cout << "outputing server list:" << endl;
	map<pair<string,int>, pair<string,int> >::iterator iter;
	for (iter = clientList.begin(); iter != clientList.end(); ++iter) {
		cout << iter->first.first << ":" << iter->first.second << " : " << iter->second.first.c_str() << ":" << iter->second.second << endl;
	}
}

node_list *file_find_1_svc(char *arg1,  struct svc_req *rqstp) {
	static node_list result;
	result.node_list_val = new node[clientList.size()];
	result.node_list_len = 0;
	client_file_list f_list;
	int pos = -1;
	int len = 0;
    strcat(arg1, " "); //appending a space so it actually searches for entire word and not any substring in filename
    cout << "node list is: \n";
	map<pair<string,int>, pair<string,int> >::iterator iter;
 	for (iter = clientList.begin(); iter != clientList.end(); ++iter) {
		f_list = new char[(iter->second.first).length() +1];
		strcpy(f_list,iter->second.first.c_str());
		string remaining_list(f_list, strlen(f_list));
		pos = remaining_list.find(arg1);
		if(pos >= 0){
			node *temp_node = result.node_list_val + len;
			temp_node->ip= new char[MAXIP];
			strcpy(temp_node->ip,iter->first.first.c_str());
			temp_node->port = iter->first.second;
			cout << temp_node->ip << ":" << temp_node->port << "\n";
            result.node_list_len++;
			len++;
			continue;
		}
		pos = -1;
	}
	return &result;
}

int *update_list_1_svc(IP arg1, int arg2, client_file_list arg3, int arg4, struct svc_req *rqstp) {
	static int  result = -1;
	stringstream self_file_list;
	self_file_list << arg3;
	map<pair<string,int>,pair<string,int> >::iterator find_itr;
	find_itr = clientList.find(make_pair(arg1,arg2));
	//add client to client list only if previously not existing
	if(find_itr == clientList.end()) {
		clientList.insert (it, std::pair<pair<string,int>,pair<string,int> >(make_pair(arg1,arg2), make_pair(self_file_list.str(),arg4)));
		it++;
	}
	else{
		find_itr->second.first = self_file_list.str();
		find_itr->second.second = arg4;
	}
	outputClientList();
	result = 0;
	return &result;
}

int *remove_client_1_svc(IP arg1, int arg2, struct svc_req *rqstp) {
    static int  result = -1;
    //removal of client from list when it fails
    map<pair<string,int>,pair<string,int> >::iterator find_itr;
    find_itr = clientList.find(make_pair(arg1,arg2));
    if(find_itr != clientList.end()) {
        clientList.erase(find_itr);
    }
    outputClientList();
    result = 0;
    return &result;
}


void ping() {
	//ping the clients every 5 sec
	map<pair<string,int>, pair<string,int> >::iterator iter;
	char temp_ip[MAXIP];
	int temp_port;
	while(1){
		sleep(5);
		for (iter = clientList.begin(); iter != clientList.end(); ++iter) {
			strcpy(temp_ip,iter->first.first.c_str());
			temp_port = iter->second.second;
			TcpClient *ping_clnt = new TcpClient(temp_ip, temp_port);
			if(ping_clnt->clntOpen() < 0){
				cout << "Failed to ping " << iter->first.first << ":" << iter->second.second << endl;
				cout << "removing client from list" << endl;
				clientList.erase(iter);
				outputClientList();
			}
			ping_clnt->clntClose();
			free(ping_clnt);
		}
	}
}

void s_fault_check(int server_port){
    map<pair<string,int>, pair<string,int> >::iterator iter;
    TcpServer *fault_check_serv = new TcpServer(server_port,MAXCLIENTS);
    socklen_t clilen = sizeof(fault_check_serv->cli_addr);
    int newsockfd;
    fault_check_serv->servListen();
    while(1){
        for (iter = clientList.begin(); iter != clientList.end(); ++iter) {
            newsockfd = accept(fault_check_serv->sockfd, (struct sockaddr *) &(fault_check_serv->cli_addr), &clilen);
            if (newsockfd < 0) {
                cout << "server fault check tcp server could not accept connection" << endl;
            }else {
//                cout << "accepted \n";
            }
        }
	}
}